#!/usr/bin/env python3
"""
Mock PAL MCP Server for Nexus CLI Integration Testing

This mock server simulates PAL MCP responses for testing purposes.
It can be configured to return specific responses or simulate failures.
"""

import json
import sys
import time
import random
from typing import Dict, Any, Optional
from dataclasses import dataclass, asdict
from enum import Enum


class MockMode(Enum):
    """Mock server operation modes"""
    NORMAL = "normal"           # Normal operation
    SLOW = "slow"               # Simulate slow responses
    INTERMITTENT = "intermittent"  # Random failures
    OFFLINE = "offline"         # Always fail


@dataclass
class MockConfig:
    """Configuration for mock server behavior"""
    mode: MockMode = MockMode.NORMAL
    delay_seconds: float = 0.5
    failure_rate: float = 0.2  # For intermittent mode
    gemini_success_rate: float = 1.0
    codex_success_rate: float = 1.0


class MockPALServer:
    """Mock PAL MCP Server"""

    def __init__(self, config: Optional[MockConfig] = None):
        self.config = config or MockConfig()
        self.call_history: list = []
        self.models = [
            {"name": "gemini-2.5-pro", "provider": "google"},
            {"name": "codex", "provider": "openai"},
            {"name": "claude-3", "provider": "anthropic"}
        ]

    def _should_fail(self, cli_name: str) -> bool:
        """Determine if this call should fail based on config"""
        if self.config.mode == MockMode.OFFLINE:
            return True
        if self.config.mode == MockMode.INTERMITTENT:
            return random.random() < self.config.failure_rate
        if cli_name == "gemini":
            return random.random() > self.config.gemini_success_rate
        if cli_name == "codex":
            return random.random() > self.config.codex_success_rate
        return False

    def _apply_delay(self):
        """Apply configured delay"""
        if self.config.mode == MockMode.SLOW:
            time.sleep(self.config.delay_seconds * 3)
        else:
            time.sleep(self.config.delay_seconds)

    def listmodels(self) -> Dict[str, Any]:
        """Mock mcp__pal__listmodels response"""
        self.call_history.append({"tool": "listmodels", "timestamp": time.time()})

        if self.config.mode == MockMode.OFFLINE:
            return {"error": "PAL MCP server is offline"}

        self._apply_delay()
        return {
            "models": self.models,
            "status": "available"
        }

    def clink(self, prompt: str, cli_name: str) -> Dict[str, Any]:
        """Mock mcp__pal__clink response"""
        call_record = {
            "tool": "clink",
            "cli_name": cli_name,
            "prompt": prompt[:100] + "..." if len(prompt) > 100 else prompt,
            "timestamp": time.time()
        }
        self.call_history.append(call_record)

        if self._should_fail(cli_name):
            return {
                "error": f"Mock {cli_name} execution failed",
                "cli_name": cli_name,
                "status": "failed"
            }

        self._apply_delay()

        # Generate mock response based on cli_name
        if cli_name == "gemini":
            response = self._generate_gemini_response(prompt)
        elif cli_name == "codex":
            response = self._generate_codex_response(prompt)
        else:
            response = self._generate_generic_response(prompt)

        return {
            "result": response,
            "cli_name": cli_name,
            "status": "success",
            "execution_time_ms": int(self.config.delay_seconds * 1000)
        }

    def _generate_gemini_response(self, prompt: str) -> str:
        """Generate mock Gemini response for frontend tasks"""
        if "component" in prompt.lower() or "ui" in prompt.lower():
            return """// Mock Gemini Response: React Component
import React from 'react';

export const MockComponent: React.FC = () => {
  return (
    <div className="mock-component">
      <h1>Mock Component</h1>
      <p>Generated by Mock PAL Server</p>
    </div>
  );
};
"""
        return f"// Mock Gemini response for: {prompt[:50]}..."

    def _generate_codex_response(self, prompt: str) -> str:
        """Generate mock Codex response for backend tasks"""
        if "api" in prompt.lower() or "endpoint" in prompt.lower():
            return """# Mock Codex Response: API Endpoint
from fastapi import FastAPI, HTTPException

app = FastAPI()

@app.get("/mock-endpoint")
async def mock_endpoint():
    return {"message": "Mock response", "status": "success"}
"""
        return f"# Mock Codex response for: {prompt[:50]}..."

    def _generate_generic_response(self, prompt: str) -> str:
        """Generate generic mock response"""
        return f"Mock response for: {prompt[:50]}..."

    def get_call_history(self) -> list:
        """Get history of all calls made to mock server"""
        return self.call_history

    def reset(self):
        """Reset mock server state"""
        self.call_history = []

    def get_stats(self) -> Dict[str, Any]:
        """Get statistics about mock server usage"""
        clink_calls = [c for c in self.call_history if c["tool"] == "clink"]
        gemini_calls = [c for c in clink_calls if c.get("cli_name") == "gemini"]
        codex_calls = [c for c in clink_calls if c.get("cli_name") == "codex"]

        return {
            "total_calls": len(self.call_history),
            "listmodels_calls": len([c for c in self.call_history if c["tool"] == "listmodels"]),
            "clink_calls": len(clink_calls),
            "gemini_calls": len(gemini_calls),
            "codex_calls": len(codex_calls),
            "config": {
                "mode": self.config.mode.value,
                "delay_seconds": self.config.delay_seconds
            }
        }


# Global mock server instance for testing
_mock_server: Optional[MockPALServer] = None


def get_mock_server(config: Optional[MockConfig] = None) -> MockPALServer:
    """Get or create mock server instance"""
    global _mock_server
    if _mock_server is None or config is not None:
        _mock_server = MockPALServer(config)
    return _mock_server


def reset_mock_server():
    """Reset mock server to initial state"""
    global _mock_server
    if _mock_server:
        _mock_server.reset()


# CLI interface for testing
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Mock PAL Server CLI")
    parser.add_argument("--mode", choices=["normal", "slow", "intermittent", "offline"],
                       default="normal", help="Server mode")
    parser.add_argument("--test", action="store_true", help="Run self-test")

    args = parser.parse_args()

    config = MockConfig(mode=MockMode(args.mode))
    server = get_mock_server(config)

    if args.test:
        print("Running mock server self-test...")
        print(f"Mode: {config.mode.value}")

        # Test listmodels
        result = server.listmodels()
        print(f"listmodels: {json.dumps(result, indent=2)}")

        # Test clink with gemini
        result = server.clink("Create a React button component", "gemini")
        print(f"clink (gemini): {result['status']}")

        # Test clink with codex
        result = server.clink("Create a REST API endpoint", "codex")
        print(f"clink (codex): {result['status']}")

        # Print stats
        stats = server.get_stats()
        print(f"Stats: {json.dumps(stats, indent=2)}")

        print("Self-test complete!")
    else:
        print(f"Mock PAL Server initialized in {config.mode.value} mode")
        print("Use --test to run self-test")
